#include<iostream>
using namespace std;
int main() {
	//IO类
	//		不能限制实际应用程序仅从控制台窗口进行操作,程序应常常需要读写命名文件
	//		程序还可能需要读写宽字符支持的语言
	//		为了支持不同种类的IO处理,标准库定义了一些IO:
	//			1.iostream
	//			2.fstream
	//			3.sstream
	//		标准库定义了一组类型和对象来操纵wchar_t类型的数据,宽字符以一个w开始
	//
	//IO类型间的关系
	//		设备类型和字符大小不会影响我们要执行的IO操作
	//		不用管读取的字符能存入char对象内还是需要wchar_t对象
	//		标准库使我们忽略这些不同类型的流之间的差异,通过继承机制,利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节
	//
	//IO对象无拷贝或赋值
	//		由于不能拷贝IO对象,所以不能将形参或返回值类型定义为流类型
	//		通常用引用方式传递和返回流
	//		读写IO对象会改变其状态,因此传递和返回的引用不能是const
	//条件状态
	//		IO操作可能发生错误
	//		IO类定义了一些函数标志,帮助我们访问和操纵流的条件状态
	//			1.strm::iostate
	//			2.strm::badbit
	//			3.strm::failbit
	//			4.strm::eofbit
	//			5.strm::goodbit
	//		由于流可能处于错误状态,因此代码通常应该在使用一个流之前检查它是否处于良好状态
	//		while(cin>>word){}
	//
	//查询流的状态
	//		将流做条件只能告诉我们流是否有效,无法得知具体发生了什么
	//		iostate提供了表达流状态的完整功能,这个类型应作为位集合使用
	//		IO定义了4个iostate类型的constexpr值,表示特定的位模式
	//			badbit:系统级错误,如不可恢复的读写错误
	//			failbit:可恢复的错误,如期望与实际输入不符时,或者文件结束置位
	//			eofbit:文件结束被置位
	//			goodbit:如果未发生错误为0
	//		标准库还定义了函数类查询标志位状态
	//			1.good()
	//			2.bad()
	//			3.fail():badbit置位返回也为true
	//			4.eof()
	//管理条件状态
	//		rdstate:成员返回一个iostate,对应流当前状态
	//		sestate:操作将给定条件位置位
	//		clear:清除(复位)所有错误标志位
	
	//管理输出缓冲
	//		每个输出流都管理一个缓冲区,来保存读写的数据
	//		有了缓冲区机制,操作系统可以将程序的多个输出操作组合成单一的系统级写操作
	//		由于是被写操作可能很费时,允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升
	//
	//导致缓冲刷新的原因很多
	//		1.程序正常结束
	//		2.缓冲区已满
	//		3.使用操控符如endl,显式刷新
	//		4.使用unitbuf设置流的内部状态,清空缓冲
	//		5.一个输出流可能被关联到另一个流,当读写被关联的流时,关联到的流的缓冲会刷新
	//
	//刷新输出缓冲区
	//		1.endl:换行并刷新
	//		2.flush:刷新
	//		3.ends:空字符刷新
	//
	//unitbuf操纵符
	//		如果想在每次输出后都刷新流使用unitbuf
	//		nounitbuf则重置流,恢复正常状态
	//
	//关联输入和输出流
	//		当一个输入流被关联到一个输出流上时,任何试图从输入流读取数据都会先刷新关联的输出流
	//			cin>>ival;
	//			cout被刷新
	//		tie:
	//			1.不带参数返回指向输出流的指针,如果关联到一个输出流,则返回输出流指针,否则返回空指针
	//			2.第二个版本接受一个指向ostream的指针,将自己关联到ostream
	//				cin.tie(&cout);
	//				ostream *old_tie = cin.tie(nulltpr);
	//				cin.tie(&cerr);
	//				cin.tie(old_tie);
	
	//文件输入输出
	//		fstream定义了三个类型支持文件IO:
	//			1.ifeatrem
	//			2.ofstream
	//			3.fstream
	//		操作与cin,cout一样
	//		除了>>,可以用getline读取数据
	//		关联了文件
	//
	//使用文件流对象
	//		定义一个文件流对象,并将对象与文件关联
	//		使用open函数打开文件
	//用fstream代替iostream&
	//		如果有一个函数接受一个ostream&参数,就可以传递fstream对象,同样的istream&和ifstream也是类似
	//
	//成员函数open和close
	//		如果定义了一个空文件流对象,可以随后使用open来将它与文件关联
	//		如果open成功则good()为true
	//
	//自动构造析构
	//		fstream对象离开器作用域时,与之关联的文件会自动关闭
	
	//文件模式
	//		1.in:输入
	//		2.out:输出
	//		3.app:写操作前均定位文件末尾
	//		4.ate:打开文件后立即定位文件末尾
	//		5.trunc:截断文件
	//		6.binary:二进制打开文件
	//		指定文件模式有如下限制:
	//			1.只可以对oftream或fstream对象设定out模式
	//			2.只可以对ifstream或fstream对象设定in模式
	//			3.只有当out也被设定时才可以设定trunc模式
	//			4.只要trunc没被设定,可以设定app模式
	//			5.默认情况下即使我们没有指定trunc,以out模式打开的文件也会被截断,为了保留文件内容,使用app模式
	//			6.ate模式和binary模式可以用于任何文件流对象,且可用于其他任何文件模式组使用
	//		每个文件流都定义了一个默认的文件模式
	//
	//以out模式打开文件会丢失已有的数据
	//每次调用open时都会确定文件模式

	//string流
	//		sstream定义了三个类型来支持内存IO,这些类型可以向string写入数据
	//			1.istringstream:从string读取数据
	//			2.ostringstream:向string写入数据
	//			3.stringstream:既可以写又可以读
	//
	//使用istringstream
	//		某些工作是对整行文本进行处理,而其他工作是处理行内的单个单词,可以使用istringstream
	//使用ostringstream
	//		希望最后一期打印时,使用ostringstream
}